<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EAR Meter v3.1 — Δ⇄⟳ Tracker</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700&family=Space+Grotesk:wght@300;400;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-dark: #0a0a0f;
            --bg-card: #12121a;
            --delta-color: #3b82f6;
            --relation-color: #10b981;
            --process-color: #ef4444;
            --text-primary: #f0f0f0;
            --text-secondary: #888;
            --alert-color: #f59e0b;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            min-height: 100dvh;
            overflow-x: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            min-height: 100dvh;
            padding: 10px;
            gap: 10px;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        .logo span { opacity: 0.5; font-weight: 300; }
        
        .status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.7rem;
            padding: 5px 10px;
            background: var(--bg-card);
            border-radius: 16px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--process-color);
        }
        
        .status-dot.active { background: var(--relation-color); }
        
        /* Video Area */
        .video-area {
            position: relative;
            flex: 1;
            min-height: 280px;
            background: var(--bg-card);
            border-radius: 12px;
            overflow: hidden;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .video-hud {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        
        .hud-item {
            font-size: 0.65rem;
            background: rgba(0,0,0,0.7);
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .video-bottom {
            position: absolute;
            bottom: 8px;
            left: 8px;
            right: 8px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }
        
        .k-display {
            font-size: 1.3rem;
            font-weight: 700;
            padding: 6px 12px;
            background: rgba(0,0,0,0.75);
            border-radius: 10px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .k-display.alert {
            border-color: var(--alert-color);
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
        }
        
        .k-display small { font-size: 0.55rem; opacity: 0.6; }
        
        .zones-count {
            font-size: 0.7rem;
            background: rgba(0,0,0,0.7);
            padding: 6px 10px;
            border-radius: 8px;
        }
        
        .zones-count span { font-weight: 700; color: var(--process-color); }
        
        /* Compact Meters */
        .meters {
            display: flex;
            gap: 8px;
            padding: 12px;
            background: var(--bg-card);
            border-radius: 12px;
        }
        
        .meter {
            flex: 1;
            text-align: center;
        }
        
        .meter-header {
            display: flex;
            justify-content: center;
            align-items: baseline;
            gap: 4px;
            margin-bottom: 6px;
        }
        
        .meter-symbol {
            font-size: 1.1rem;
            font-weight: 700;
        }
        
        .meter-symbol.delta { color: var(--delta-color); }
        .meter-symbol.relation { color: var(--relation-color); }
        .meter-symbol.process { color: var(--process-color); }
        
        .meter-value {
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .meter-bar-bg {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .meter-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.15s;
        }
        
        .meter-bar.delta { background: var(--delta-color); }
        .meter-bar.relation { background: var(--relation-color); }
        .meter-bar.process { background: var(--process-color); }
        
        .meter-label {
            font-size: 0.55rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-top: 4px;
        }
        
        /* State Row */
        .state-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }
        
        .state-card {
            padding: 10px 6px;
            background: var(--bg-card);
            border-radius: 10px;
            text-align: center;
        }
        
        .state-card h4 {
            font-size: 0.5rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        
        .state-card .value {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .value.stable { color: var(--relation-color); }
        .value.warning { color: var(--alert-color); }
        .value.alert { color: var(--process-color); }
        
        /* Timeline */
        .timeline {
            padding: 10px;
            background: var(--bg-card);
            border-radius: 10px;
        }
        
        .timeline h4 {
            font-size: 0.55rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 6px;
        }
        
        #timelineCanvas {
            width: 100%;
            height: 40px;
            background: rgba(255,255,255,0.02);
            border-radius: 4px;
        }
        
        /* Start Overlay */
        .start-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 10, 15, 0.97);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
            text-align: center;
        }
        
        .start-overlay.hidden { display: none; }
        
        .start-title {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 6px;
            background: linear-gradient(135deg, var(--delta-color), var(--relation-color), var(--process-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .start-subtitle {
            color: var(--text-secondary);
            margin-bottom: 20px;
            font-size: 0.9rem;
        }
        
        .explanation {
            max-width: 300px;
            margin-bottom: 20px;
            text-align: left;
        }
        
        .exp-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin-bottom: 6px;
            background: var(--bg-card);
            border-radius: 8px;
        }
        
        .exp-symbol {
            font-size: 1.2rem;
            font-weight: 700;
            width: 32px;
            text-align: center;
        }
        
        .exp-text strong { display: block; font-size: 0.8rem; }
        .exp-text span { font-size: 0.65rem; color: var(--text-secondary); }
        
        .start-btn {
            padding: 12px 36px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--delta-color), var(--process-color));
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .loading { 
            margin-top: 12px; 
            color: var(--text-secondary);
            font-size: 0.8rem;
        }
        
        .loading.hidden { display: none; }
        
        .alert-flash {
            position: fixed;
            inset: 0;
            background: rgba(245, 158, 11, 0.12);
            pointer-events: none;
            opacity: 0;
            z-index: 50;
            transition: opacity 0.1s;
        }
        
        .alert-flash.active { opacity: 1; }
    </style>
</head>
<body>
    <div class="alert-flash" id="alertFlash"></div>
    
    <div class="start-overlay" id="startOverlay">
        <div class="start-title">EAR Meter v3.1</div>
        <div class="start-subtitle">Motion Tracking con Marker</div>
        
        <div class="explanation">
            <div class="exp-item">
                <div class="exp-symbol" style="color: var(--delta-color)">Δ</div>
                <div class="exp-text">
                    <strong>Stabilità</strong>
                    <span>Zone ferme, struttura</span>
                </div>
            </div>
            <div class="exp-item">
                <div class="exp-symbol" style="color: var(--relation-color)">⇄</div>
                <div class="exp-text">
                    <strong>Bordo</strong>
                    <span>Confine movimento/quiete</span>
                </div>
            </div>
            <div class="exp-item">
                <div class="exp-symbol" style="color: var(--process-color)">⟳</div>
                <div class="exp-text">
                    <strong>Movimento</strong>
                    <span>Zone attive, tracked con marker</span>
                </div>
            </div>
        </div>
        
        <button class="start-btn" id="startBtn">Avvia Camera</button>
        <div class="loading hidden" id="loading">Accesso alla camera...</div>
    </div>
    
    <div class="container">
        <div class="header">
            <div class="logo">EAR <span>v3.1</span></div>
            <div class="status">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">In attesa</span>
            </div>
        </div>
        
        <div class="video-area">
            <video id="video" playsinline autoplay muted></video>
            <canvas id="overlayCanvas"></canvas>
            <div class="video-hud">
                <div class="hud-item" id="fps">-- fps</div>
                <div class="hud-item" id="activity">Attività: --</div>
            </div>
            <div class="video-bottom">
                <div class="zones-count">Zone ⟳: <span id="zonesCount">0</span></div>
                <div class="k-display" id="kDisplay">
                    <span id="kValue">0.000</span>
                    <small> K</small>
                </div>
            </div>
        </div>
        
        <div class="meters">
            <div class="meter">
                <div class="meter-header">
                    <div class="meter-symbol delta">Δ</div>
                    <div class="meter-value" id="valDelta">0%</div>
                </div>
                <div class="meter-bar-bg">
                    <div class="meter-bar delta" id="barDelta" style="width: 0%"></div>
                </div>
                <div class="meter-label">Stabile</div>
            </div>
            <div class="meter">
                <div class="meter-header">
                    <div class="meter-symbol relation">⇄</div>
                    <div class="meter-value" id="valRelation">0%</div>
                </div>
                <div class="meter-bar-bg">
                    <div class="meter-bar relation" id="barRelation" style="width: 0%"></div>
                </div>
                <div class="meter-label">Bordo</div>
            </div>
            <div class="meter">
                <div class="meter-header">
                    <div class="meter-symbol process">⟳</div>
                    <div class="meter-value" id="valProcess">0%</div>
                </div>
                <div class="meter-bar-bg">
                    <div class="meter-bar process" id="barProcess" style="width: 0%"></div>
                </div>
                <div class="meter-label">Motion</div>
            </div>
        </div>
        
        <div class="state-row">
            <div class="state-card">
                <h4>Stato</h4>
                <div class="value stable" id="stateVal">--</div>
            </div>
            <div class="state-card">
                <h4>Dominante</h4>
                <div class="value" id="dominantVal">--</div>
            </div>
            <div class="state-card">
                <h4>Max zona</h4>
                <div class="value" id="maxZoneVal">--</div>
            </div>
            <div class="state-card">
                <h4>Transizioni</h4>
                <div class="value" id="transitionVal">0</div>
            </div>
        </div>
        
        <div class="timeline">
            <h4>K Timeline (30s)</h4>
            <canvas id="timelineCanvas"></canvas>
        </div>
    </div>

    <script>
        // ============================================
        // EAR METER v3.1 - Motion Tracking con Marker
        // ============================================
        
        const CONFIG = {
            K_CRIT: 0.35,
            MOTION_THRESHOLD: 25,
            EDGE_RADIUS: 2,
            UPDATE_INTERVAL: 80,
            SMOOTHING: 0.25,
            TIMELINE_DURATION: 30,
            ANALYSIS_SCALE: 0.2,
            // Clustering
            MIN_ZONE_SIZE: 50,          // Pixel minimi per una zona
            GRID_SIZE: 8,               // Griglia per clustering veloce
            MAX_ZONES: 10               // Max zone da tracciare
        };
        
        // Stato
        let isRunning = false;
        let previousFrame = null;
        let currentEAR = { delta: 0.33, relation: 0.33, process: 0.33 };
        let lastEAR = { delta: 0.33, relation: 0.33, process: 0.33 };
        let kHistory = [];
        let transitionCount = 0;
        let frameCount = 0;
        let lastFpsTime = Date.now();
        let detectedZones = [];
        
        // Elementi DOM
        const el = {
            startOverlay: document.getElementById('startOverlay'),
            startBtn: document.getElementById('startBtn'),
            loading: document.getElementById('loading'),
            video: document.getElementById('video'),
            overlayCanvas: document.getElementById('overlayCanvas'),
            statusDot: document.getElementById('statusDot'),
            statusText: document.getElementById('statusText'),
            fps: document.getElementById('fps'),
            activity: document.getElementById('activity'),
            zonesCount: document.getElementById('zonesCount'),
            kDisplay: document.getElementById('kDisplay'),
            kValue: document.getElementById('kValue'),
            barDelta: document.getElementById('barDelta'),
            barRelation: document.getElementById('barRelation'),
            barProcess: document.getElementById('barProcess'),
            valDelta: document.getElementById('valDelta'),
            valRelation: document.getElementById('valRelation'),
            valProcess: document.getElementById('valProcess'),
            stateVal: document.getElementById('stateVal'),
            dominantVal: document.getElementById('dominantVal'),
            maxZoneVal: document.getElementById('maxZoneVal'),
            transitionVal: document.getElementById('transitionVal'),
            timelineCanvas: document.getElementById('timelineCanvas'),
            alertFlash: document.getElementById('alertFlash')
        };
        
        // Canvas per elaborazione
        const processCanvas = document.createElement('canvas');
        const processCtx = processCanvas.getContext('2d', { willReadFrequently: true });
        
        // Avvio
        el.startBtn.addEventListener('click', startApp);
        
        async function startApp() {
            el.startBtn.style.display = 'none';
            el.loading.classList.remove('hidden');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    },
                    audio: false
                });
                
                el.video.srcObject = stream;
                await el.video.play();
                
                const w = el.video.videoWidth || 640;
                const h = el.video.videoHeight || 480;
                
                el.overlayCanvas.width = w;
                el.overlayCanvas.height = h;
                
                processCanvas.width = Math.floor(w * CONFIG.ANALYSIS_SCALE);
                processCanvas.height = Math.floor(h * CONFIG.ANALYSIS_SCALE);
                
                el.timelineCanvas.width = el.timelineCanvas.offsetWidth * 2;
                el.timelineCanvas.height = el.timelineCanvas.offsetHeight * 2;
                
                el.startOverlay.classList.add('hidden');
                el.statusDot.classList.add('active');
                el.statusText.textContent = 'Attivo';
                
                isRunning = true;
                requestAnimationFrame(analyzeLoop);
                
            } catch (err) {
                console.error(err);
                el.loading.textContent = 'Errore: ' + err.message;
            }
        }
        
        function analyzeLoop() {
            if (!isRunning) return;
            
            processCtx.drawImage(el.video, 0, 0, processCanvas.width, processCanvas.height);
            const currentFrame = processCtx.getImageData(0, 0, processCanvas.width, processCanvas.height);
            
            if (previousFrame) {
                const result = analyzeMotion(previousFrame, currentFrame);
                
                currentEAR.delta = lerp(currentEAR.delta, result.ear.delta, CONFIG.SMOOTHING);
                currentEAR.relation = lerp(currentEAR.relation, result.ear.relation, CONFIG.SMOOTHING);
                currentEAR.process = lerp(currentEAR.process, result.ear.process, CONFIG.SMOOTHING);
                
                detectedZones = result.zones;
                
                const k = calculateK(lastEAR, currentEAR);
                
                kHistory.push({ time: Date.now(), k });
                const cutoff = Date.now() - CONFIG.TIMELINE_DURATION * 1000;
                kHistory = kHistory.filter(h => h.time > cutoff);
                
                if (k > CONFIG.K_CRIT) {
                    transitionCount++;
                    triggerAlert();
                }
                
                updateUI(k);
                drawOverlay(result.motionMap);
                
                lastEAR = { ...currentEAR };
            }
            
            previousFrame = currentFrame;
            
            frameCount++;
            if (Date.now() - lastFpsTime > 1000) {
                el.fps.textContent = frameCount + ' fps';
                frameCount = 0;
                lastFpsTime = Date.now();
            }
            
            setTimeout(() => requestAnimationFrame(analyzeLoop), CONFIG.UPDATE_INTERVAL);
        }
        
        function analyzeMotion(prev, curr) {
            const w = prev.width;
            const h = prev.height;
            const total = w * h;
            
            const motionMap = new Uint8Array(total);
            const motionIntensity = new Float32Array(total);
            
            let deltaCount = 0;
            let processCount = 0;
            
            // Pass 1: Detect motion
            for (let i = 0; i < total; i++) {
                const idx = i * 4;
                const prevLum = prev.data[idx] * 0.299 + prev.data[idx+1] * 0.587 + prev.data[idx+2] * 0.114;
                const currLum = curr.data[idx] * 0.299 + curr.data[idx+1] * 0.587 + curr.data[idx+2] * 0.114;
                const diff = Math.abs(currLum - prevLum);
                
                motionIntensity[i] = diff;
                
                if (diff > CONFIG.MOTION_THRESHOLD) {
                    motionMap[i] = 1;
                    processCount++;
                } else {
                    motionMap[i] = 0;
                    deltaCount++;
                }
            }
            
            // Pass 2: Find edges
            let relationCount = 0;
            const r = CONFIG.EDGE_RADIUS;
            
            for (let y = r; y < h - r; y++) {
                for (let x = r; x < w - r; x++) {
                    const i = y * w + x;
                    if (motionMap[i] === 0) {
                        let hasMovingNeighbor = false;
                        for (let dy = -r; dy <= r && !hasMovingNeighbor; dy++) {
                            for (let dx = -r; dx <= r && !hasMovingNeighbor; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                if (motionMap[(y + dy) * w + (x + dx)] === 1) {
                                    hasMovingNeighbor = true;
                                }
                            }
                        }
                        if (hasMovingNeighbor) {
                            motionMap[i] = 2;
                            relationCount++;
                            deltaCount--;
                        }
                    }
                }
            }
            
            // Pass 3: Find motion zones using grid-based clustering
            const zones = findMotionZones(motionMap, motionIntensity, w, h);
            
            return {
                ear: {
                    delta: deltaCount / total,
                    relation: relationCount / total,
                    process: processCount / total
                },
                motionMap: motionMap,
                zones: zones
            };
        }
        
        function findMotionZones(motionMap, intensity, w, h) {
            const gridW = Math.ceil(w / CONFIG.GRID_SIZE);
            const gridH = Math.ceil(h / CONFIG.GRID_SIZE);
            const grid = new Float32Array(gridW * gridH);
            
            // Accumula movimento per cella
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (motionMap[y * w + x] === 1) {
                        const gx = Math.floor(x / CONFIG.GRID_SIZE);
                        const gy = Math.floor(y / CONFIG.GRID_SIZE);
                        grid[gy * gridW + gx] += intensity[y * w + x];
                    }
                }
            }
            
            // Trova celle con molto movimento
            const hotCells = [];
            for (let gy = 0; gy < gridH; gy++) {
                for (let gx = 0; gx < gridW; gx++) {
                    const val = grid[gy * gridW + gx];
                    if (val > CONFIG.MIN_ZONE_SIZE * CONFIG.MOTION_THRESHOLD) {
                        hotCells.push({ gx, gy, val });
                    }
                }
            }
            
            // Clustering semplice: unisci celle adiacenti
            const zones = [];
            const visited = new Set();
            
            for (const cell of hotCells) {
                const key = `${cell.gx},${cell.gy}`;
                if (visited.has(key)) continue;
                
                // BFS per trovare cluster
                const cluster = [];
                const queue = [cell];
                let totalVal = 0;
                let minX = cell.gx, maxX = cell.gx;
                let minY = cell.gy, maxY = cell.gy;
                
                while (queue.length > 0) {
                    const c = queue.shift();
                    const k = `${c.gx},${c.gy}`;
                    if (visited.has(k)) continue;
                    visited.add(k);
                    
                    cluster.push(c);
                    totalVal += c.val;
                    minX = Math.min(minX, c.gx);
                    maxX = Math.max(maxX, c.gx);
                    minY = Math.min(minY, c.gy);
                    maxY = Math.max(maxY, c.gy);
                    
                    // Check neighbors
                    for (const neighbor of hotCells) {
                        const nk = `${neighbor.gx},${neighbor.gy}`;
                        if (!visited.has(nk)) {
                            const dx = Math.abs(neighbor.gx - c.gx);
                            const dy = Math.abs(neighbor.gy - c.gy);
                            if (dx <= 1 && dy <= 1) {
                                queue.push(neighbor);
                            }
                        }
                    }
                }
                
                if (cluster.length > 0) {
                    // Converti coordinate griglia in pixel (scala analisi)
                    const scale = 1 / CONFIG.ANALYSIS_SCALE;
                    zones.push({
                        x: minX * CONFIG.GRID_SIZE * scale,
                        y: minY * CONFIG.GRID_SIZE * scale,
                        w: (maxX - minX + 1) * CONFIG.GRID_SIZE * scale,
                        h: (maxY - minY + 1) * CONFIG.GRID_SIZE * scale,
                        intensity: totalVal / cluster.length,
                        cells: cluster.length
                    });
                }
            }
            
            // Ordina per intensità e limita
            zones.sort((a, b) => b.intensity - a.intensity);
            return zones.slice(0, CONFIG.MAX_ZONES);
        }
        
        function drawOverlay(motionMap) {
            const ctx = el.overlayCanvas.getContext('2d');
            const cw = el.overlayCanvas.width;
            const ch = el.overlayCanvas.height;
            const w = processCanvas.width;
            const h = processCanvas.height;
            
            ctx.clearRect(0, 0, cw, ch);
            
            // Disegna motion map semi-trasparente
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tempCtx = tempCanvas.getContext('2d');
            const imageData = tempCtx.createImageData(w, h);
            
            for (let i = 0; i < motionMap.length; i++) {
                const idx = i * 4;
                const type = motionMap[i];
                
                if (type === 0) {
                    // Delta - quasi invisibile
                    imageData.data[idx + 3] = 0;
                } else if (type === 1) {
                    // Process - rosso
                    imageData.data[idx] = 239;
                    imageData.data[idx + 1] = 68;
                    imageData.data[idx + 2] = 68;
                    imageData.data[idx + 3] = 100;
                } else {
                    // Relation - verde
                    imageData.data[idx] = 16;
                    imageData.data[idx + 1] = 185;
                    imageData.data[idx + 2] = 129;
                    imageData.data[idx + 3] = 120;
                }
            }
            
            tempCtx.putImageData(imageData, 0, 0);
            ctx.drawImage(tempCanvas, 0, 0, cw, ch);
            
            // Disegna marker per ogni zona
            ctx.lineWidth = 2;
            ctx.font = 'bold 12px JetBrains Mono';
            
            detectedZones.forEach((zone, idx) => {
                // Colore basato su intensità
                const intensity = Math.min(zone.intensity / 5000, 1);
                const r = Math.round(239 + (255 - 239) * intensity);
                const g = Math.round(68 * (1 - intensity));
                const b = Math.round(68 * (1 - intensity));
                
                // Box
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.15)`;
                
                ctx.beginPath();
                ctx.roundRect(zone.x, zone.y, zone.w, zone.h, 6);
                ctx.fill();
                ctx.stroke();
                
                // Centro marker
                const cx = zone.x + zone.w / 2;
                const cy = zone.y + zone.h / 2;
                
                // Crosshair
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                ctx.beginPath();
                ctx.moveTo(cx - 10, cy);
                ctx.lineTo(cx + 10, cy);
                ctx.moveTo(cx, cy - 10);
                ctx.lineTo(cx, cy + 10);
                ctx.stroke();
                
                // Label
                const label = `⟳${idx + 1}`;
                ctx.fillStyle = `rgba(0, 0, 0, 0.7)`;
                ctx.fillRect(zone.x, zone.y - 18, 32, 16);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillText(label, zone.x + 4, zone.y - 5);
                
                // Intensità
                const pct = Math.round(intensity * 100);
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(zone.x + zone.w - 30, zone.y - 18, 30, 16);
                ctx.fillStyle = '#fff';
                ctx.fillText(pct + '%', zone.x + zone.w - 26, zone.y - 5);
            });
            
            // Se nessuna zona, mostra messaggio
            if (detectedZones.length === 0 && currentEAR.process < 0.02) {
                ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
                ctx.font = 'bold 16px Space Grotesk';
                ctx.textAlign = 'center';
                ctx.fillText('Δ STABILE — Nessun movimento', cw / 2, ch / 2);
                ctx.textAlign = 'left';
            }
        }
        
        function calculateK(prev, curr) {
            const dD = curr.delta - prev.delta;
            const dR = curr.relation - prev.relation;
            const dP = curr.process - prev.process;
            return Math.sqrt(dD*dD + dR*dR + dP*dP);
        }
        
        function updateUI(k) {
            // Barre
            el.barDelta.style.width = (currentEAR.delta * 100) + '%';
            el.barRelation.style.width = (currentEAR.relation * 100) + '%';
            el.barProcess.style.width = (currentEAR.process * 100) + '%';
            
            // Valori
            el.valDelta.textContent = Math.round(currentEAR.delta * 100) + '%';
            el.valRelation.textContent = Math.round(currentEAR.relation * 100) + '%';
            el.valProcess.textContent = Math.round(currentEAR.process * 100) + '%';
            
            // K
            el.kValue.textContent = k.toFixed(3);
            el.kDisplay.classList.toggle('alert', k > CONFIG.K_CRIT);
            
            // Zone count
            el.zonesCount.textContent = detectedZones.length;
            
            // Stato
            if (k > CONFIG.K_CRIT) {
                el.stateVal.textContent = 'TRANS';
                el.stateVal.className = 'value alert';
            } else if (k > CONFIG.K_CRIT * 0.5) {
                el.stateVal.textContent = 'VAR';
                el.stateVal.className = 'value warning';
            } else {
                el.stateVal.textContent = 'STAB';
                el.stateVal.className = 'value stable';
            }
            
            // Dominante
            const max = Math.max(currentEAR.delta, currentEAR.relation, currentEAR.process);
            if (max === currentEAR.delta) {
                el.dominantVal.textContent = 'Δ';
                el.dominantVal.style.color = 'var(--delta-color)';
            } else if (max === currentEAR.relation) {
                el.dominantVal.textContent = '⇄';
                el.dominantVal.style.color = 'var(--relation-color)';
            } else {
                el.dominantVal.textContent = '⟳';
                el.dominantVal.style.color = 'var(--process-color)';
            }
            
            // Max zona
            if (detectedZones.length > 0) {
                const maxZone = detectedZones[0];
                const size = Math.round((maxZone.w * maxZone.h) / (el.overlayCanvas.width * el.overlayCanvas.height) * 100);
                el.maxZoneVal.textContent = size + '%';
                el.maxZoneVal.style.color = 'var(--process-color)';
            } else {
                el.maxZoneVal.textContent = '--';
                el.maxZoneVal.style.color = 'var(--text-secondary)';
            }
            
            // Attività HUD
            const act = currentEAR.process;
            let actText, actColor;
            if (act < 0.03) {
                actText = 'QUIETE';
                actColor = 'var(--delta-color)';
            } else if (act < 0.12) {
                actText = 'BASSA';
                actColor = 'var(--relation-color)';
            } else if (act < 0.30) {
                actText = 'MEDIA';
                actColor = 'var(--alert-color)';
            } else {
                actText = 'ALTA';
                actColor = 'var(--process-color)';
            }
            el.activity.innerHTML = `Attività: <span style="color:${actColor};font-weight:bold">${actText}</span>`;
            
            // Transizioni
            el.transitionVal.textContent = transitionCount;
            
            drawTimeline();
        }
        
        function drawTimeline() {
            const canvas = el.timelineCanvas;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = 'rgba(255,255,255,0.015)';
            ctx.fillRect(0, 0, w, h);
            
            if (kHistory.length < 2) return;
            
            const now = Date.now();
            const duration = CONFIG.TIMELINE_DURATION * 1000;
            
            // K_crit line
            const critY = h - (CONFIG.K_CRIT / 0.5) * h;
            ctx.strokeStyle = 'rgba(245, 158, 11, 0.35)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(0, critY);
            ctx.lineTo(w, critY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // K curve
            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            let started = false;
            for (const p of kHistory) {
                const x = ((p.time - (now - duration)) / duration) * w;
                const y = h - Math.min(p.k / 0.5, 1) * h;
                if (!started) { ctx.moveTo(x, y); started = true; }
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Alert points
            ctx.fillStyle = 'var(--process-color)';
            for (const p of kHistory) {
                if (p.k > CONFIG.K_CRIT) {
                    const x = ((p.time - (now - duration)) / duration) * w;
                    const y = h - Math.min(p.k / 0.5, 1) * h;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function triggerAlert() {
            if (navigator.vibrate) navigator.vibrate([60, 30, 60]);
            el.alertFlash.classList.add('active');
            setTimeout(() => el.alertFlash.classList.remove('active'), 120);
        }
        
        function lerp(a, b, t) { return a + (b - a) * t; }
        
        window.addEventListener('resize', () => {
            el.timelineCanvas.width = el.timelineCanvas.offsetWidth * 2;
            el.timelineCanvas.height = el.timelineCanvas.offsetHeight * 2;
        });
    </script>
</body>
</html>
